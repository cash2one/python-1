# **********************************************************************
#
# Copyright (c) 2003-2010 ZeroC, Inc. All rights reserved.
#
# This copy of Ice is licensed to you under the terms described in the
# ICE_LICENSE file included in this distribution.
#
# **********************************************************************

# Ice version 3.4.1

# <auto-generated>
#
# Generated from file `Endpoint.ice'
#
# Warning: do not edit this file.
#
# </auto-generated>

import Ice, IcePy, __builtin__
import Ice_BuiltinSequences_ice
import Ice_EndpointF_ice

# Included module Ice
_M_Ice = Ice.openModule('Ice')

# Start of module Ice
__name__ = 'Ice'

_M_Ice.TCPEndpointType = 1

_M_Ice.UDPEndpointType = 3

if not _M_Ice.__dict__.has_key('EndpointInfo'):
    _M_Ice.EndpointInfo = Ice.createTempClass()
    class EndpointInfo(object):
        '''Base class providing access to the endpoint details.'''
        def __init__(self, timeout=0, compress=False):
            if __builtin__.type(self) == _M_Ice.EndpointInfo:
                raise RuntimeError('Ice.EndpointInfo is an abstract class')
            self.timeout = timeout
            self.compress = compress

        def type(self):
            '''Returns the type of the endpoint.'''
            pass

        def datagram(self):
            '''Returns true if this endpoint is a datagram endpoint.'''
            pass

        def secure(self):
            '''Returns true if this endpoint is a secure endpoint.'''
            pass

        def __str__(self):
            return IcePy.stringify(self, _M_Ice._t_EndpointInfo)

        __repr__ = __str__

    _M_Ice._t_EndpointInfo = IcePy.defineClass('::Ice::EndpointInfo', EndpointInfo, (), True, None, (), (
        ('timeout', (), IcePy._t_int),
        ('compress', (), IcePy._t_bool)
    ))
    EndpointInfo._ice_type = _M_Ice._t_EndpointInfo

    _M_Ice.EndpointInfo = EndpointInfo
    del EndpointInfo

if not _M_Ice.__dict__.has_key('Endpoint'):
    _M_Ice.Endpoint = Ice.createTempClass()
    class Endpoint(object):
        '''The user-level interface to an endpoint.'''
        def __init__(self):
            if __builtin__.type(self) == _M_Ice.Endpoint:
                raise RuntimeError('Ice.Endpoint is an abstract class')

        def toString(self):
            '''Return a string representation of the endpoint.

Returns:
    The string representation of the endpoint.'''
            pass

        def getInfo(self):
            '''Returns the endpoint information.

Returns:
    The endpoint information class.'''
            pass

        def __str__(self):
            return IcePy.stringify(self, _M_Ice._t_Endpoint)

        __repr__ = __str__

    _M_Ice._t_Endpoint = IcePy.defineClass('::Ice::Endpoint', Endpoint, (), True, None, (), ())
    Endpoint._ice_type = _M_Ice._t_Endpoint

    _M_Ice.Endpoint = Endpoint
    del Endpoint

if not _M_Ice.__dict__.has_key('IPEndpointInfo'):
    _M_Ice.IPEndpointInfo = Ice.createTempClass()
    class IPEndpointInfo(_M_Ice.EndpointInfo):
        '''Provides access to the address details of a IP endpoint.'''
        def __init__(self, timeout=0, compress=False, host='', port=0):
            if __builtin__.type(self) == _M_Ice.IPEndpointInfo:
                raise RuntimeError('Ice.IPEndpointInfo is an abstract class')
            _M_Ice.EndpointInfo.__init__(self, timeout, compress)
            self.host = host
            self.port = port

        def __str__(self):
            return IcePy.stringify(self, _M_Ice._t_IPEndpointInfo)

        __repr__ = __str__

    _M_Ice._t_IPEndpointInfo = IcePy.defineClass('::Ice::IPEndpointInfo', IPEndpointInfo, (), True, _M_Ice._t_EndpointInfo, (), (
        ('host', (), IcePy._t_string),
        ('port', (), IcePy._t_int)
    ))
    IPEndpointInfo._ice_type = _M_Ice._t_IPEndpointInfo

    _M_Ice.IPEndpointInfo = IPEndpointInfo
    del IPEndpointInfo

if not _M_Ice.__dict__.has_key('TCPEndpointInfo'):
    _M_Ice.TCPEndpointInfo = Ice.createTempClass()
    class TCPEndpointInfo(_M_Ice.IPEndpointInfo):
        '''Provides access to a TCP endpoint information.'''
        def __init__(self, timeout=0, compress=False, host='', port=0):
            if __builtin__.type(self) == _M_Ice.TCPEndpointInfo:
                raise RuntimeError('Ice.TCPEndpointInfo is an abstract class')
            _M_Ice.IPEndpointInfo.__init__(self, timeout, compress, host, port)

        def __str__(self):
            return IcePy.stringify(self, _M_Ice._t_TCPEndpointInfo)

        __repr__ = __str__

    _M_Ice._t_TCPEndpointInfo = IcePy.defineClass('::Ice::TCPEndpointInfo', TCPEndpointInfo, (), True, _M_Ice._t_IPEndpointInfo, (), ())
    TCPEndpointInfo._ice_type = _M_Ice._t_TCPEndpointInfo

    _M_Ice.TCPEndpointInfo = TCPEndpointInfo
    del TCPEndpointInfo

if not _M_Ice.__dict__.has_key('UDPEndpointInfo'):
    _M_Ice.UDPEndpointInfo = Ice.createTempClass()
    class UDPEndpointInfo(_M_Ice.IPEndpointInfo):
        '''Provides access to an UDP endpoint information.'''
        def __init__(self, timeout=0, compress=False, host='', port=0, protocolMajor=0, protocolMinor=0, encodingMajor=0, encodingMinor=0, mcastInterface='', mcastTtl=0):
            if __builtin__.type(self) == _M_Ice.UDPEndpointInfo:
                raise RuntimeError('Ice.UDPEndpointInfo is an abstract class')
            _M_Ice.IPEndpointInfo.__init__(self, timeout, compress, host, port)
            self.protocolMajor = protocolMajor
            self.protocolMinor = protocolMinor
            self.encodingMajor = encodingMajor
            self.encodingMinor = encodingMinor
            self.mcastInterface = mcastInterface
            self.mcastTtl = mcastTtl

        def __str__(self):
            return IcePy.stringify(self, _M_Ice._t_UDPEndpointInfo)

        __repr__ = __str__

    _M_Ice._t_UDPEndpointInfo = IcePy.defineClass('::Ice::UDPEndpointInfo', UDPEndpointInfo, (), True, _M_Ice._t_IPEndpointInfo, (), (
        ('protocolMajor', (), IcePy._t_byte),
        ('protocolMinor', (), IcePy._t_byte),
        ('encodingMajor', (), IcePy._t_byte),
        ('encodingMinor', (), IcePy._t_byte),
        ('mcastInterface', (), IcePy._t_string),
        ('mcastTtl', (), IcePy._t_int)
    ))
    UDPEndpointInfo._ice_type = _M_Ice._t_UDPEndpointInfo

    _M_Ice.UDPEndpointInfo = UDPEndpointInfo
    del UDPEndpointInfo

if not _M_Ice.__dict__.has_key('OpaqueEndpointInfo'):
    _M_Ice.OpaqueEndpointInfo = Ice.createTempClass()
    class OpaqueEndpointInfo(_M_Ice.EndpointInfo):
        '''Provides access to the details of an opaque endpoint.'''
        def __init__(self, timeout=0, compress=False, rawBytes=None):
            if __builtin__.type(self) == _M_Ice.OpaqueEndpointInfo:
                raise RuntimeError('Ice.OpaqueEndpointInfo is an abstract class')
            _M_Ice.EndpointInfo.__init__(self, timeout, compress)
            self.rawBytes = rawBytes

        def __str__(self):
            return IcePy.stringify(self, _M_Ice._t_OpaqueEndpointInfo)

        __repr__ = __str__

    _M_Ice._t_OpaqueEndpointInfo = IcePy.defineClass('::Ice::OpaqueEndpointInfo', OpaqueEndpointInfo, (), True, _M_Ice._t_EndpointInfo, (), (('rawBytes', (), _M_Ice._t_ByteSeq),))
    OpaqueEndpointInfo._ice_type = _M_Ice._t_OpaqueEndpointInfo

    _M_Ice.OpaqueEndpointInfo = OpaqueEndpointInfo
    del OpaqueEndpointInfo

# End of module Ice
